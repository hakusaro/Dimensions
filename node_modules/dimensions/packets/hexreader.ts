import Color from 'dimensions/color';
import { hex2a } from 'dimensions/utils';
import * as utf8 from 'utf8';
import NetworkText from 'dimensions/packets/networktext';

/**
 * Reads datatypes from a hex string
 */
class HexReader {
  protected _data: string;

  constructor(data: string) {
    this._data = data;
  }

  /**
   * Gets the data still stored by the reader
   * 
   * @return The hex data still stored by the reader
   */
  public get data(): string {
    return this._data;
  }
  
  /**
   * Removes a byte from the data
   * 
   * @return The byte removed
   */
  readByte(): number {
    // Read byte and convert to int
    let byte: number = parseInt(this._data.substr(0, 2), 16);

    // Chop off read data
    this._data = this._data.substr(2);

    return byte;
  }
  
  /**
   * Removes a certain number of bytes from the data
   * 
   * @return The bytes removed
   */
  readBytes(amount: number): string {
    let bytes = "";
    for (let i = 0; i < amount; i++) {
      bytes += this.readByte();
    }

    return bytes;
  }

  /**
   * Removes three bytes from the data and puts them into a color object
   * 
   * @return The color object {R, G, B}
   */
  readColor(): Color {
    let color = {
      R: this.readByte(),
      G: this.readByte(),
      B: this.readByte()
    };

    return color;
  }

  /**
   * Removes a byte and converts it into an sbyte
   * 
   * @return The sbyte removed
   */
  readSByte(): number {
    let byte: number = parseInt(this._data.substr(0, 2), 16);

    // Chop off read data
    this._data = this._data.substr(2);

    // If MSB is active, ensure minus
    let msb = 128;
    if ((byte & msb) == msb) {
	    byte = -msb+(byte & (msb-1));
    }

    return byte;
  }

  /**
   * Removes 2 bytes from the data, converting it to a signed int16
   * as an int16.
   * 
   * perf: https://jsperf.com/conv-dimen-1
   * @return An int16
   */
  readInt16(): number {
    let int16 = this.readUInt16();

    // If MSB is active, ensure minus
    let msb = 32768;
    if ((int16 & msb) == msb) {
	    int16 = -msb+(int16 & (msb-1));
    }

    return int16;
  }

  /**
   * Removes 2 bytes from the data and converts it to an unsigned int16
   * 
   * @return A uint16
   */
  readUInt16(): number {
    // Read bytes
    let firstByte: string = this._data.substr(2, 2);
    let secondByte: string = this._data.substr(0, 2);

    // Convert to int
    let uint16: number = parseInt(firstByte + secondByte, 16);

    // Chop off read data
    this._data = this._data.substr(4);

    return uint16;
  }

  /**
   * Removes 4 bytes from the data, converting it into a signed int32 
   * 
   * Perf: https://jsperf.com/conv-dimen-1
   * @return The signed int32 removed from the data
   */
  readInt32(): number {
    let int32: number = this.readUInt32();

    // Conver to minus if MSB is active
    let msb = 2147483648;
    int32 = int32 & msb + ~(int32 & msb);

    return int32;
  }

  /**
   * Removes 4 bytes from the data, converting it into an unsigned int32
   * 
   * @return The unsigned int32 removed from the data
   */
  readUInt32(): number {
    // Read bytes
    let firstByte: string = this._data.substr(6, 2);
    let secondByte: string = this._data.substr(4, 2);
    let thirdByte: string = this._data.substr(2, 2);
    let fourthByte: string = this._data.substr(0, 2);

    // Convert to int
    let uint32: number = parseInt(firstByte + secondByte + thirdByte + fourthByte, 16);

    // Chop off read data
    this._data = this._data.substr(8);

    return uint32;
  }

  /**
   * Removes 8 bytes from the data, converting it into an unsigned int64
   * 
   * @return The unsigned int64 removed from the data
   */
  readUInt64(): number {
    // Read bytes
    let firstByte: string = this._data.substr(14, 2);
    let secondByte: string = this._data.substr(12, 2);
    let thirdByte: string = this._data.substr(10, 2);
    let fourthByte: string = this._data.substr(8, 2);
    let fifthByte: string = this._data.substr(6, 2);
    let sixthByte: string = this._data.substr(4, 2);
    let seventhByte: string = this._data.substr(2, 2);
    let eighthByte: string = this._data.substr(0, 2);

    // Convert to int
    let uint32: number = parseInt(firstByte + secondByte + thirdByte + fourthByte + fifthByte + sixthByte + seventhByte + eighthByte, 16);

    // Chop off read data
    this._data = this._data.substr(16);

    return uint32;
  }

  /**
   * Removes 4 bytes from the data converting it into a single
   * 
   * @return The single removed from the data
   */
  readSingle(): number {
    // Get hex string
    let hex: string = this._data.substr(0, 8);

    // Use buffer to read Float
    let buf: Buffer = new Buffer(hex, 'hex');
    let single: number = buf.readFloatLE(0);

    // Chop off read data
    this._data = this._data.substr(8);

    return single;
  }

  /**
   * Removes a certain number of bytes for the string length, and then further
   * bytes depending on the length, converting it into a string of characters.
   * 
   * @return The string removed from the data
   */
  readString(): string {
    // Read string length
    let firstByte: number = parseInt(this._data.substr(0, 2), 16);
    let strLength: number = firstByte;
    let digitOffset = 2;
    if (firstByte >= 128) {
      let secondByte: string = this._data.substr(2, 2);
      strLength = firstByte + (parseInt(secondByte, 16) - 1) * 128;
      digitOffset = 4;
    }

    // The used string length is in hex digits rather than characters
    strLength *= 2;

    // Read string content using length
    let strContent: string = utf8.decode(hex2a(this._data.substr(digitOffset, strLength)));

    // Chop off read data
    this._data = this._data.substr(digitOffset + strLength);
    return strContent;
  }

  /**
   * Removes the mode byte and the string bytes
   * 
   * @return The text
   */
  readNetworkText(): NetworkText {
    let mode = this.readByte();
    let text = this.readString();

    return new NetworkText(mode, text);
  }
}

export default HexReader;