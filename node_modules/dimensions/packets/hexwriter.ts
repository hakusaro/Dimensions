import Color from 'dimensions/color';
import { a2hex, getCorrectHex } from 'dimensions/utils';
import * as utf8 from 'utf8';
import NetworkText from 'dimensions/packets/networktext';

/**
 * Writes datatypes as hex to a string
 */
class HexWriter {
    protected _data: string;

    constructor() {
        this._data = "";
    }

    /**
     * Writes a string using hex values of each character with the length
     * at the beginning.
     * 
     * @param str The string to pack as hex
     * @return This writer
     */
    public packString(str: string): HexWriter {
        let strHex: string = a2hex(utf8.encode(str));
        let sizeOfString: number = strHex.length / 2;
        let strLengthInHex: string;

        /* Sizes >= 128 require an extra byte (and maybe more but I doubt
            we will get bigger than strings of length 255*128) */
        if (sizeOfString >= 128) {
            strLengthInHex = getCorrectHex(((sizeOfString % 128) + 128).toString(16)) + getCorrectHex(Math.floor(sizeOfString / 128).toString(16));
        } else {
            strLengthInHex = getCorrectHex((strHex.length / 2).toString(16));
        }

        this._data += strLengthInHex + strHex;
        return this;
    }

    /**
     * Writes network text
     * 
     * @param text The text to pack as network text
     * @param mode The mode (0 = Literal, 1 = Formattable, 2 = LocalizationKey)
     * @return This writer
     */
    public packNetworkText(networkText: NetworkText): HexWriter {
      this.packByte(networkText.mode);
      this.packString(networkText.text);
      return this;
    }

    /**
     * Writes already packed hex data into this writers data
     * 
     * @param hex The hex data to append to the current writers data
     * @return This writer
     */
    public packHex(hex: string): HexWriter {
        this._data += hex;
        return this;
    }

    /**
     * Writes a byte to the hex data
     * 
     * @param byte The byte to pack as hex
     * @return This writer
     */
    public packByte(byte: number): HexWriter {
        if (byte < 0) {
            byte = -byte;
        }

        if (byte > 255) {
            byte = 0;
        }

        // 2 hex digits
        let intHex: string = (byte).toString(16);
        if (intHex.length !== 2) {
            for (let j: number = intHex.length; j < 2; j++) {
                intHex = "0" + intHex;
            }
        }

        this._data += intHex;
        return this;
    }

    /**
     * Writes a color object to the hex data
     * 
     * @param color The color object to pack as 3 bytes in hex
     * @return This writer
     */
    public packColor(color: Color): HexWriter {
        this.packByte(color.R);
        this.packByte(color.G);
        this.packByte(color.B);
        return this;
    }

    /**
     * Writes an int16 to the hex data
     * 
     * @param int16 The int16 to pack as hex
     * @return This writer
     */
    public packInt16(int16: number): HexWriter {
        // Gets rid of first 16 bits of the 32 bit input number
        if (int16 < 0) {
            int16 = (int16 << 16) >>> 16;
            int16 |= 32768;
        }

        // 4 hex digits
        var intHex = (int16).toString(16);
        if (intHex.length !== 4) {
            for (let j: number = intHex.length; j < 4; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        var secondByte: string = intHex.substr(2, 2);
        intHex = secondByte + firstByte;
        this._data += intHex;
        return this;
    }

    /**
     * Writes a uint16 to the hex data
     * 
     * @param uint16 The uint16 to pack as hex
     * @return This writer
     */
    public packUInt16(uint16: number): HexWriter {
        // 4 hex digits
        var intHex = (uint16).toString(16);
        if (intHex.length !== 4) {
            for (let j: number = intHex.length; j < 4; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        var secondByte: string = intHex.substr(2, 2);
        intHex = secondByte + firstByte;
        this._data += intHex;
        return this;
    }

    /**
     * Writes an int32 to the hex data
     * 
     * @param int32 The int32 to pack as hex
     * @return This writer
     */
    public packInt32(int32: number): HexWriter {
        if (int32 < 0) {
            int32 = (int32 << 32) >>> 32;
            int32 |= 2147483648;
            int32 = int32 >>> 0;
        }

        let intHex: string = (int32).toString(16);
        if (intHex.length !== 8) {
            for (let j: number = intHex.length; j < 8; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        let secondByte: string = intHex.substr(2, 2);
        let thirdByte: string = intHex.substr(4, 2);
        let fourthByte: string = intHex.substr(6, 2);
        intHex = fourthByte + thirdByte + secondByte + firstByte;
        this._data += intHex;
        return this;
    }

    /**
     * Writes a uint32 to the hex data
     * 
     * @param uint32 The uint32 to pack as hex
     * @return This writer
     */
    public packUInt32(uint32: number): HexWriter {
        let intHex: string = (uint32).toString(16);
        if (intHex.length !== 8) {
            for (let j: number = intHex.length; j < 8; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        let secondByte: string = intHex.substr(2, 2);
        let thirdByte: string = intHex.substr(4, 2);
        let fourthByte: string = intHex.substr(6, 2);
        intHex = fourthByte + thirdByte + secondByte + firstByte;
        this._data += intHex;
        return this;
    }    

    /**
     * Writes a uint64 to the hex data
     * 
     * @param uint64 The uint64 to pack as hex
     * @return This writer
     */
    public packUInt64(uint64: number): HexWriter {
        let intHex: string = (uint64).toString(16);
        if (intHex.length !== 16) {
            for (let j: number = intHex.length; j < 16; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        let secondByte: string = intHex.substr(2, 2);
        let thirdByte: string = intHex.substr(4, 2);
        let fourthByte: string = intHex.substr(6, 2);
        let fifthByte: string = intHex.substr(8, 2);
        let sixthByte: string = intHex.substr(10, 2);
        let seventhByte: string = intHex.substr(12, 2);
        let eighthByte: string = intHex.substr(14, 2);
        intHex = eighthByte + seventhByte + sixthByte + fifthByte + fourthByte + thirdByte + secondByte + firstByte;
        this._data += intHex;
        return this;
    }

    /**
     * Writes a single to the hex data
     * 
     * @param single The single to pack as hex
     * @return This writer
     */
    public packSingle(single: number): HexWriter {
        let tempBuffer: Buffer = new Buffer(4);
        tempBuffer.writeFloatLE(single, 0);
        let packedSingle: string = tempBuffer.toString('hex');
        this._data += packedSingle;
        return this;
    }

    /**
     * Gets the data stored by the writer
     * 
     * @return The data stored by the writer
     */
    public get data(): string {
        return this._data;
    }
}

export default HexWriter;